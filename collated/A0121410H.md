# A0121410H
###### src\sg\edu\cs2103aug2015_w13_2j\commands\AddHandler.java
``` java

/**
 * {@link CommandHandler} which handles adding a {@link Task} object to the
 * master list of {@link Task} objects. A name for the {@link Task} is required
 * and optionally the start and end dates can be specified.<br>
 * <br>
 * User feedback {@value #ADD_SUCCESS} will be displayed to indicate that the
 * task was added successfully. If no task name was specified, the
 * {@link FeedbackMessage#ERROR_INVALID_TASK} error message will be shown.
 * 
 * @author Zhu Chunqi
 */
public class AddHandler extends CommandHandler {
    public static final String ADD_SUCCESS = "Task added successfully.";

    private static final String NAME = "Add Task";
    private static final String SYNTAX = "<TASK_NAME> [-e DATETIME] [-s DATETIME]";
    private static final String[] FLAGS = { FLAG_START, FLAG_END };
    private static final String[] OPTIONS = { OPTION_TASK_NAME, OPTION_DATETIME };
    private static final String[] RESERVED = { "add", "a" };

    public AddHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        Task task = new Task();
        try {
            updateTask(command, task);
            assert (task.isValid());
            logic.addTask(task);
            logic.clearRedoHistory();
            logic.storeCommandInHistory();
            logic.feedback(new FeedbackMessage(ADD_SUCCESS, FeedbackType.INFO));
        } catch (InvalidTaskException e) {
            logic.feedback(FeedbackMessage.ERROR_INVALID_TASK);
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\CommandHandler.java
``` java

/**
 * Base abstract class inherited by all command handlers. Provides default
 * methods to set and retrieve the name, syntax, flags, options and reserved
 * keyword strings of the command handlers. Also provides a method to update
 * {@link Task} objects from information contained within a {@link Command}
 * object.
 * 
 * @author Zhu Chunqi
 */
public abstract class CommandHandler {
    protected static final String FLAG_START = "-s: Specifies the start date/time of the Task.";
    protected static final String FLAG_END = "-e: Specifies the end date/time of the Task.";

    protected static final String OPTION_DATETIME = "DATETIME: Any valid combination of the supported date and time formats.";
    protected static final String OPTION_FILTER_NAME = "FILTER_NAME: A valid filter name.";
    protected static final String OPTION_TASK_ID = "TASK_ID: The index of the Task as displayed.";
    protected static final String OPTION_TASK_NAME = "TASK_NAME: Name to be given to this Task. Must be surrounded by either single (') or double quotes (\").";
    protected static final String OPTION_SEARCH_TERM = "SEARCH_TERM: Any word or quoted phrase.";

    private String mName;
    private String mSyntax;
    private String[] mFlags;
    private String[] mOptions;
    private String[] mReserved;

    /**
     * Constructor for all {@link CommandHandler} objects. Stores the name,
     * syntax, supported flags, supported options and reserved keyword strings
     * of the {@link CommandHandler}. Each inheriting {@link CommandHandler}
     * <b>must</b> provide valid parameters as the values are <b>not</b>
     * initialized by default.
     * 
     * @param name
     *            Name of this {@link CommandHandler}.
     * @param syntax
     *            Syntax required by this {@link CommandHandler}.
     * @param flags
     *            String array of flags supported and their descriptions.
     * @param options
     *            String array of options supported and their descriptions.
     * @param reserved
     *            Array of reserved keyword strings handled by this
     *            {@link CommandHandler}.
     */
    public CommandHandler(String name, String syntax, String[] flags,
            String[] options, String[] reserved) {
        mName = name;
        mSyntax = syntax;
        mFlags = flags;
        mOptions = options;
        mReserved = reserved;
    }

    /**
     * Executes the functionality of this {@link CommandHandler} based on the
     * provided {@link Command} object.
     * 
     * @param logic
     *            Dependency injection of {@link LogicInterface} component to
     *            allow this {@link CommandHandler} to function.
     * @param command
     *            {@link Command} object containing parsed {@link Token} objects
     *            from user input.
     */
    public abstract void execute(LogicInterface logic, Command command);

    /**
     * Retrieves the name of this {@link CommandHandler}.
     * 
     * @return Name of this {@link CommandHandler}.
     */
    public String getName() {
        return mName;
    }

    /**
     * Retrieves the syntax required by this {@link CommandHandler}.
     * 
     * @return Syntax required by this {@link CommandHandler}.
     */
    public String getSyntax() {
        return mSyntax;
    }

    /**
     * Retrieves a <b>sorted</b> list of flags and their descriptions supported
     * by this {@link CommandHandler}.
     * 
     * @return Sorted list of flags and their descriptions.
     */
    public List<String> getFlags() {
        return getSortedList(mFlags);
    }

    /**
     * Retrieves a <b>sorted</b> list of options and their descriptions that are
     * supported by this {@link CommandHandler}.
     * 
     * @return Sorted list of options and their descriptions.
     */
    public List<String> getOptions() {
        return getSortedList(mOptions);
    }

    /**
     * Retrieves a <b>sorted</b> list of reserved keyword strings handled by
     * this {@link CommandHandler}. The list may include simple aliases or
     * keywords with completely different functionality.
     * 
     * @return Sorted list of reserved keyword strings handled by this
     *         {@link CommandHandler}.
     */
    public List<String> getReservedKeywords() {
        return getSortedList(mReserved);
    }

    /**
     * Checks if this {@link CommandHandler} requires a display refresh after
     * execution. Defaults to {@code true} for all {@link CommandHandler}s
     * unless {@link #shouldDisplay()} is explicitly overridden to return
     * {@code false}.
     * 
     * @return {@code True} if this {@link CommandHandler} requires a display
     *         refresh after execution, {@code false} otherwise.
     */
    public boolean shouldDisplay() {
        return true;
    }

    /**
     * Updates the provided {@link Task} object based on the provided
     * {@link Command} object.
     * 
     * @param command
     *            {@link Command} object created from user input.
     * @param task
     *            {@link Task} object to be updated.
     * @throws InvalidTaskException
     *             Thrown when the {@link Task} object modified by the
     *             {@link Command} object becomes invalid.
     */
    public void updateTask(Command command, Task task)
            throws InvalidTaskException {
        Iterator<Token> iter = command.iterator();
        while (iter.hasNext()) {
            Token token = iter.next();
            switch (token.type) {
              case FLAG :
                // Flags which expect the next token to be a date
                String flag = token.value;
                switch (flag) {
                  case Parser.FLAG_END :
                    // Falls through
                  case Parser.FLAG_START :
                    if (iter.hasNext()) {
                        Token nextToken = iter.next();
                        if (nextToken.type == Token.Type.DATE) {
                            if (flag.compareTo(Parser.FLAG_END) == 0) {
                                task.setEnd(nextToken.value);
                            } else if (flag.compareTo(
                                    Parser.FLAG_START) == 0) {
                                task.setStart(nextToken.value);
                            }
                        }
                    }
                    break;
                }
                break;
              case NAME :
                if (token.value.length() == 0) {
                    throw new InvalidTaskException();
                } else {
                    task.setName(token.value);
                    break;
                }
              default :
                // Do nothing
                break;
            }
        }
        task.isValid();
        determineType(task);
    }

```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\CommandHandler.java
``` java

    /**
     * Converts an array of strings into a sorted list of strings.
     * 
     * @param array
     *            Array of strings to be sorted.
     * @return Sorted list of strings.
     */
    private List<String> getSortedList(String[] array) {
        List<String> list = Arrays.asList(array);
        Collections.sort(list);
        return list;
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\DeleteHandler.java
``` java

/**
 * {@link CommandHandler} which handles deleting one or more {@link Task}
 * objects from the master list of {@link Task} objects. One or more indices
 * associated with {@link Task} objects must be specified.<br>
 * <br>
 * User feedback {@value #DELETE_SUCCESS} will be displayed to indicate that the
 * {@link Task} object(s) were deleted successfully. If an index specified is
 * out of range, the {@link FeedbackMessage#ERROR_TASK_NOT_FOUND} error message
 * will be shown.
 */
public class DeleteHandler extends CommandHandler {
    public static final String DELETE_SUCCESS = "Task deleted successfully.";

    private static final Logger LOGGER = Logger
            .getLogger(Logic.class.getName());
    private static final String NAME = "Delete Task";
    private static final String SYNTAX = "<TASK_ID>";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = { OPTION_TASK_ID };
    private static final String[] RESERVED = { "delete", "del", "remove", "rm" };

    private LogicInterface mLogic;

    public DeleteHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public List<String> getReservedKeywords() {
        return Arrays.asList(RESERVED);
    }

```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\EditHandler.java
``` java

/**
 * {@link CommandHandler} which handles editing the details of a {@link Task}
 * object in the master list of {@link Task} objects. An index referring to the
 * {@link Task} object to be edited must be specified. Optionally, a new task
 * name, start date or end date can be specified.
 * 
 * User feedback {@value #EDIT_SUCCESS} will be displayed to indicate that the
 * {@link Task} object was edited successfully. If the index specified is out of
 * range, the {@link FeedbackMessage#ERROR_TASK_NOT_FOUND} error message will be
 * shown. If the {@link Task} object becomes invalid after the edit, the
 * {@link FeedbackMessage#ERROR_INVALID_TASK} error message will be shown.
 * 
 * @author Zhu Chunqi
 */
public class EditHandler extends CommandHandler {
    public static final String EDIT_SUCCESS = "Task edited successfully.";

    private static final String NAME = "Edit Task";
    private static final String SYNTAX = "<TASK_ID> [TASK_NAME] [-e DATETIME] [-s DATETIME]";
    private static final String[] FLAGS = { FLAG_START, FLAG_END };
    private static final String[] OPTIONS = { OPTION_TASK_ID, OPTION_TASK_NAME,
            OPTION_DATETIME };
    private static final String[] RESERVED = { "edit", "e" };

    public EditHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        Token id = command.getIdToken();
        try {
            int indexToEdit = Integer.parseInt(id.value);
            Task task = logic.getTask(indexToEdit);
            updateTask(command, task);
            assert (task.isValid());
            logic.storeCommandInHistory();
            logic.clearRedoHistory();
            logic.feedback(new FeedbackMessage(EDIT_SUCCESS, FeedbackType.INFO));
        } catch (NumberFormatException e) {
            logic.feedback(FeedbackMessage.ERROR_INVALID_INDEX);
        } catch (TaskNotFoundException e) {
            logic.feedback(FeedbackMessage.ERROR_TASK_NOT_FOUND);
        } catch (InvalidTaskException e) {
            logic.feedback(FeedbackMessage.ERROR_INVALID_TASK);
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\FilterHandler.java
``` java

/**
 * {@link CommandHandler} which handles filtering {@link Task} objects to obtain
 * a subset of {@link Task} objects with specific properties. A valid filter
 * name must be specified.
 * 
 * User feedback {@value #FILTER_SUCCESS} will be displayed to indicate that the
 * specified filter was applied successfully. If the filter specified is not
 * valid, the {@link FeedbackMessage#ERROR_INVALID_FILTER} error message will be
 * shown.
 */
public class FilterHandler extends CommandHandler {
    public static final String FILTER_SUCCESS = "Tasks filtered.";

    private static final String NAME = "Filter Tasks";
    private static final String SYNTAX = "<FILTER_NAME>";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = { OPTION_FILTER_NAME };
    private static final String[] RESERVED = { "filter" };

    public FilterHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        Token alpha = command.getAlphaToken();
        switch (alpha.value) {
          case "active" :
            logic.pushFilter(new ActiveFilter());
            break;
          case "important" :
            logic.pushFilter(new ImportantFilter());
            break;
          default :
            logic.feedback(FeedbackMessage.ERROR_INVALID_FILTER);
            return;
        }
        logic.feedback(new FeedbackMessage(FILTER_SUCCESS, FeedbackType.INFO));
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\HelpHandler.java
``` java

/**
 * {@link CommandHandler} which handles showing the FunDUE Help Page to the
 * user. Internally calls {@link LogicInterface#showHelpPage()}.
 * 
 * User feedback {@value #HELP_SUCCESS} will be displayed to indicate that the
 * FunDUE Help Page has been opened. If the FunDUE Help Page was already open,
 * the {@value #HELP_NOACTION} message will be shown.
 * 
 * @author Zhu Chunqi
 */
public class HelpHandler extends CommandHandler {
    public static final String HELP_SUCCESS = "Showing FunDUE Help Page.";
    public static final String HELP_NOACTION = "FunDUE Help Page is already open.";

    private static final String NAME = "Help";
    private static final String SYNTAX = "";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = {};
    private static final String[] RESERVED = { "h", "help", "?" };

    public HelpHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        if (logic.showHelpPage()) {
            logic.feedback(new FeedbackMessage(HELP_SUCCESS, FeedbackType.INFO));
        } else {
            logic.feedback(new FeedbackMessage(HELP_NOACTION, FeedbackType.INFO));
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\LoadHandler.java
``` java

/**
 * {@link CommandHandler} which handles showing a file picker dialog to change
 * the FunDUE Data File. Internally calls
 * {@link LogicInterface#showChangeDataFilePathDialog()}.
 * 
 * User feedback {@value #LOAD_SUCCESS} will be displayed to indicate that the
 * FunDUE Data File has been changed. If no file was chosen in the file picker
 * dialog, the {@value #LOAD_CANCEL} message will be shown.
 * 
 * @author Zhu Chunqi
 */
public class LoadHandler extends CommandHandler {
    private static final String LOAD_SUCCESS = "Loaded FunDUE Data File successfully!";
    private static final String LOAD_CANCEL = "FunDUE Data File was not changed.";

    private static final String NAME = "Load FunDUE Data File";
    private static final String SYNTAX = "";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = {};
    private static final String[] RESERVED = { "load" };

    public LoadHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        if (logic.showChangeDataFilePathDialog()) {
            logic.feedback(new FeedbackMessage(LOAD_SUCCESS, FeedbackType.INFO));
        } else {
            logic.feedback(new FeedbackMessage(LOAD_CANCEL, FeedbackType.INFO));
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\PopHandler.java
``` java

/**
 * Pops or removes a filter already specified by the user.
 * 
 * A user feedback message will subsequently be displayed to indicate that this
 * filter was removed successfully. If there are no more applied filter(s)
 * remaining, a user feedback message will be displayed to inform the user.
 */
public class PopHandler extends CommandHandler {
    private static final String NAME = "Pop Filter";
    private static final String SYNTAX = "";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = {};
    private static final String[] RESERVED = { "pop", "back" };
    public static final String POP_SUCCESS = "Last filter removed.";
    public static final String POP_FAIL = "No filters active.";

    public PopHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        if (logic.popFilter() == null) {
            logic.feedback(new FeedbackMessage(POP_FAIL, FeedbackType.ERROR));
        } else {
            logic.feedback(new FeedbackMessage(POP_SUCCESS, FeedbackType.INFO));
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\commands\SearchHandler.java
``` java

/**
 * {@link CommandHandler} which handles searching for {@link Task} objects
 * containing one or more specified search terms. One or more single word or
 * quoted phrase search terms must be specified.
 * 
 * User feedback {@value #SEARCH_SUCCESS} will be displayed to indicate that the
 * search filter was applied successfully.
 * 
 * @author Zhu Chunqi
 */
public class SearchHandler extends CommandHandler {
    public static final String SEARCH_SUCCESS = "Search filter added.";

    private static final String NAME = "Search For Tasks";
    private static final String SYNTAX = "<SEARCH_TERM>...";
    private static final String[] FLAGS = {};
    private static final String[] OPTIONS = { OPTION_SEARCH_TERM };
    private static final String[] RESERVED = { "s", "search" };

    public SearchHandler() {
        super(NAME, SYNTAX, FLAGS, OPTIONS, RESERVED);
    }

    @Override
    public void execute(LogicInterface logic, Command command) {
        ArrayList<String> needles = new ArrayList<String>();
        command.removeReservedToken();
        for (Token token : command) {
            needles.add(token.value);
        }
        logic.pushFilter(new SearchFilter(needles));
        logic.feedback(new FeedbackMessage(SEARCH_SUCCESS, FeedbackType.INFO));
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\ActiveFilter.java
``` java

/**
 * {@link Filter} class that filters for active tasks. An active {@link Task} is
 * one that is <b>not</b> marked as complete.<br>
 * <br>
 * The filter predicate is as follows:<br>
 * 
 * <pre>
 * !task.isCompleted()
 * </pre>
 * 
 * @author Zhu Chunqi
 */
public class ActiveFilter extends Filter {
    public ActiveFilter() {
        mName = "is:active";
    }

    public void applyFilter(ArrayList<Task> tasks) {
        mTasks = new ArrayList<Task>();
        for (Task task : tasks) {
            if (!task.isCompleted()) {
                mTasks.add(task);
            }
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\Filter.java
``` java

/**
 * Base Filter class which all functional Filters extend from.
 * 
 * @author Zhu Chunqi
 */
public abstract class Filter {
    protected String mName = "filter";
    protected ArrayList<Task> mTasks;

    /**
     * Applies the functionality of this {@link Filter} to the provided list of
     * {@link Task} objects. The filtered list of {@link Task} objects can be
     * retrieved by calling {@link #getTasks()}.
     * 
     * @param tasks
     *            List of {@link Task} objects to be filtered.
     */
    public abstract void applyFilter(ArrayList<Task> tasks);

    /**
     * Retrieves the filtered list of {@link Task} objects.
     * 
     * @return Filtered list of {@link Task} objects.
     */
    public ArrayList<Task> getTasks() {
        return mTasks;
    }

    /**
     * Adds the provided {@link Task} object to the list of {@link Task} objects
     * stored in this {@link Filter}.
     * 
     * @param task
     *            {@link Task} object to be added.
     */
    public void addTask(Task task) {
        mTasks.add(task);
    }

    /**
     * Retrieves the {@link Task} object associated with the provided index.
     * Throws an exception if the provided index is out of bounds.
     * 
     * @param index
     *            Index of {@link Task} object to retrieve.
     * @return {@link Task} object associated with the provided index.
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds.
     */
    public Task getTask(int index) throws TaskNotFoundException {
        try {
            return mTasks.get(index);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Removes the {@link Task} object associated with the provided index.
     * Throws an exception if the index is out of bounds.
     * 
     * @param task
     *            {@link Task} object to be removed.
     * @return {@link Task} object associated with the provided index.
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds.
     */
    public Task removeTask(Task task) throws TaskNotFoundException {
        try {
            int index = mTasks.indexOf(task);
            return mTasks.remove(index);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Retrieves the name of this {@link Filter}.
     * 
     * @return String name of this {@link Filter}.
     */
    public String getFilterName() {
        return mName;
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\FilterChain.java
``` java

/**
 * The FilterChain class encapsulates a {@link Stack} of {@link Filter} objects
 * and provides methods to {@code push} and {@code pop} {@link Filter} objects
 * to the {@link Stack}.
 * 
 * @author Zhu Chunqi
 */
public class FilterChain {
    private static final Logger LOGGER = Logger
            .getLogger(FilterChain.class.getName());

    private final Stack<Filter> mFilters = new Stack<Filter>();

    /**
     * Zero-parameter constructor. Internally calls the alternative constructor
     * {@link #FilterChain(ArrayList)} with a new empty list.
     */
    public FilterChain() {
        this(new ArrayList<Task>());
    }

    /**
     * Class constructor. Initializes a new {@link IdentityFilter} as the root
     * of the filter chain stack seeded with the provided list of {@link Task}
     * objects.
     * 
     * @param tasks
     *            List of {@link Task} objects to seed the root {@link Filter}
     *            object.
     */
    public FilterChain(ArrayList<Task> tasks) {
        Filter root = new IdentityFilter();
        root.applyFilter(tasks);
        mFilters.push(root);
    }

    /**
     * Retrieves the size of the filter chain stack. The number returned is
     * always <b>at least 1</b> as the root {@link IdentityFilter} cannot be
     * removed.
     * 
     * @return Number of {@link Filter} objects in this {@link FilterChain}.
     */
    public int size() {
        return mFilters.size();
    }

    /**
     * Retrieves a sorted list of {@link Task} objects after being filtered
     * through the filter chain.
     * 
     * @return Sorted list of {@link Task} objects.
     */
    public ArrayList<Task> getTasksForDisplay() {
        Collections.sort(mFilters.peek().getTasks());
        return mFilters.peek().getTasks();
    }

    /**
     * Retrieves a sorted list of {@link Task} objects from the <b>root</b>
     * {@link Filter} object in the filter chain, i.e. the list of {@link Task}
     * objects that this {@link FilterChain} was seeded with.
     * 
     * @return Sorted list of {@link Task} objects.
     */
    public ArrayList<Task> getTasks() {
        Collections.sort(mFilters.elementAt(0).getTasks());
        return mFilters.elementAt(0).getTasks();
    }

    /**
     * Updates all {@link Filter}s in the filter chain stack by chaining calls
     * to {@link Filter#applyFilter(ArrayList)}, beginning with the list of
     * {@link Task} objects in the root {@link Filter}.
     */
    public void updateFilters() {
        ArrayList<Task> tasks = mFilters.elementAt(0).getTasks();
        for (Filter filter : mFilters) {
            filter.applyFilter(tasks);
            tasks = filter.getTasks();
        }
    }

    /**
     * Re-seeds the filter chain with the provided list of {@link Task} objects.
     * Internally calls {@link Filter#applyFilter(ArrayList)} on the root
     * {@link Filter} object with the provided list of Task objects and then
     * propagates the changes by calling {@link #updateFilters()}.
     * 
     * @param tasks
     *            List of {@link Task} objects to seed the root {@link Filter}.
     */
    public void updateFilters(ArrayList<Task> tasks) {
        mFilters.get(0).applyFilter(tasks);
        updateFilters();
    }

    /**
     * Adds the provided {@link Filter} object to the filter chain stack and
     * applies its filter functionality. It then becomes the final filter from
     * which the indices of displayed {@link Task} objects are derived.
     * 
     * @param filter
     *            {@link Filter} object to add to the filter chain stack.
     */
    public void pushFilter(Filter filter) {
        filter.applyFilter(mFilters.peek().getTasks());
        mFilters.push(filter);
        LOGGER.log(Level.INFO, "Pushed filter: " + filter.getFilterName());
    }

    /**
     * Pops and returns the final {@link Filter} object from the filter chain
     * stack. If only the root {@link IdentityFilter} left, this method does
     * nothing and returns {@code null}.
     * 
     * @return Popped {@link Filter} or {@code null} if only the root
     *         {@link IdentityFilter} is left.
     */
    public Filter popFilter() {
        if (mFilters.size() > 1) {
            LOGGER.log(Level.INFO,
                    "Popped filter: " + mFilters.peek().getFilterName());
            return mFilters.pop();
        } else {
            LOGGER.log(Level.WARNING, "Cannot pop root filter");
            return null;
        }
    }

    /**
     * Retrieves a string representation of all the {@link Filter} objects in
     * the filter chain stack. The name of each {@link Filter} object is
     * retrieved via {@link Filter#getFilterName()} and appended with {@code /}
     * as the separator.
     * 
     * @return String representation of all the {@link Filter} objects in the
     *         filter chain stack.
     */
    public String getFilterChain() {
        StringBuilder sb = new StringBuilder("/");
        for (Filter filter : mFilters) {
            sb.append(filter.getFilterName());
            sb.append("/");
        }
        return sb.toString();
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\IdentityFilter.java
``` java

/**
 * {@link Filter} class that does not modify the {@link Task} list in any way.
 * Suitable to be used as the root {@link Filter} of a {@link FilterChain} to
 * contain the seed list of {@link Task} objects.
 * 
 * @author Zhu Chunqi
 *
 */
public class IdentityFilter extends Filter {
    public IdentityFilter() {
        mName = "all";
    }

    public void applyFilter(ArrayList<Task> tasks) {
        mTasks = tasks;
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\ImportantFilter.java
``` java

/**
 * {@link Filter} class that filters for important tasks. An important
 * {@link Task} is one which has been marked as complete via
 * {@link Task#setCompleted(boolean)} with a value of {@code true}.<br>
 * <br>
 * The filter predicate is as follows:<br>
 * 
 * <pre>
 * task.isImportant()
 * </pre>
 * 
 * @author Zhu Chunqi
 */
public class ImportantFilter extends Filter {
    public ImportantFilter() {
        mName = "is:important";
    }

    public void applyFilter(ArrayList<Task> tasks) {
        mTasks = new ArrayList<Task>();
        for (Task task : tasks) {
            if (task.isImportant()) {
                mTasks.add(task);
            }
        }
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\filters\SearchFilter.java
``` java

/**
 * {@link Filter} class that filters for tasks containing the provided search
 * terms. A {@link Task} is kept if the name retrieved via
 * {@link Task#getName()} contains <b>any</b> of the needles.<br>
 * <br>
 * The filter predicate <b>for any needle</b> is as follows:<br>
 * 
 * <pre>
 * task.getName().contains(needle)
 * </pre>
 * 
 * @author Zhu Chunqi
 */
public class SearchFilter extends Filter {
    private ArrayList<String> mNeedles;

    public SearchFilter(ArrayList<String> needles) {
        mNeedles = needles;
        // Concatenate the search terms to form the filter name
        mName = "search:" + String.join(",", mNeedles);
    }

    @Override
    public void applyFilter(ArrayList<Task> tasks) {
        mTasks = new ArrayList<Task>();
        for (Task task : tasks) {
            for (String needle : mNeedles) {
                if (task.getName().contains(needle)) {
                    mTasks.add(task);
                    break;
                }
            }
        }
    }

}
```
###### src\sg\edu\cs2103aug2015_w13_2j\FunDueFX.java
``` java

/**
 * Main FunDUE class and JavaFX entry point. Extends the JavaFX
 * {@link Application} class.
 * 
 * @author Zhu Chunqi
 */
public class FunDueFX extends Application {
    // Initial width and height of the FunDUE window
    public static final int START_WIDTH = 700;
    public static final int START_HEIGHT = 600;

    // Minimum width and height that the FunDUE window can be resized to
    public static final int MIN_WIDTH = 550;
    public static final int MIN_HEIGHT = 500;

    // Retrieve singleton instances of application dependencies
    private UIInterface mUI = FXUI.getInstance();
    private LogicInterface mLogic = Logic.getInstance();
    private StorageInterface mStorage = Storage.getInstance();

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Register all the command handlers
        mLogic.registerCommandHandler(new AddHandler());
        mLogic.registerCommandHandler(new EditHandler());
        mLogic.registerCommandHandler(new DeleteHandler());
        mLogic.registerCommandHandler(new MarkImportantHandler());
        mLogic.registerCommandHandler(new MarkCompletedHandler());
        mLogic.registerCommandHandler(new UndoHandler());
        mLogic.registerCommandHandler(new RedoHandler());
        mLogic.registerCommandHandler(new FilterHandler());
        mLogic.registerCommandHandler(new PopHandler());
        mLogic.registerCommandHandler(new HelpHandler());
        mLogic.registerCommandHandler(new LoadHandler());
        mLogic.registerCommandHandler(new SearchHandler());

        // Create the main FunDUE window and style it
        Scene scene = new Scene(mUI.getUI(), START_WIDTH, START_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.getIcons().add(new Image("file:FunDUE Logo.png"));
        primaryStage.setTitle("FunDUE");
        primaryStage.setScene(scene);
        primaryStage.show();

        mUI.injectDependency(mLogic);
        mUI.focusCommandBar();
        mLogic.injectDependencies(mStorage, mUI);
        mLogic.readTasks();
        mLogic.display();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\Logic.java
``` java

/**
 * Implementation of a {@link LogicInterface} component.
 * 
 * @author Zhu Chunqi
 */
public class Logic implements LogicInterface {
    private static final Logger LOGGER = Logger
            .getLogger(Logic.class.getName());

    private static Logic sInstance;

    private final HashMap<String, CommandHandler> mCommandHandlers;
    private final Stack<ArrayList<Task>> mHistoryUndoStack;
    private final Stack<ArrayList<Task>> mHistoryRedoStack;
    private final ArrayList<Task> mTasks;

    // Dependencies
    private UIInterface mUI;
    private StorageInterface mStorage;

    /**
     * Private constructor
     */
    private Logic() {
        mCommandHandlers = new HashMap<String, CommandHandler>();
        mHistoryUndoStack = new Stack<ArrayList<Task>>();
        mHistoryRedoStack = new Stack<ArrayList<Task>>();
        mTasks = new ArrayList<Task>();
    }

    /**
     * Retrieves the singleton instance of this {@link LogicInterface}
     * component.
     * 
     * @return {@link LogicInterface} component
     */
    public synchronized static LogicInterface getInstance() {
        if (sInstance == null) {
            sInstance = new Logic();
        }
        return sInstance;
    }

    @Override
    public void injectDependencies(StorageInterface storage,
            UIInterface textUI) {
        assert (storage != null);
        assert (textUI != null);
        mStorage = storage;
        mUI = textUI;
    }

    @Override
    public Set<String> getReservedKeywords() {
        return mCommandHandlers.keySet();
    }

    @Override
    public HashMap<String, CommandHandler> getCommandHandlers() {
        return mCommandHandlers;
    }

    @Override
    public void registerCommandHandler(CommandHandler handler) {
        List<String> reserved = handler.getReservedKeywords();
        for (String keyword : reserved) {
            if (mCommandHandlers.containsKey(keyword)) {
                LOGGER.log(Level.WARNING,
                        "Conflicting command handlers for: " + keyword);
            } else {
                mCommandHandlers.put(keyword, handler);
            }
        }
    }

    @Override
    public void executeCommand(String commandString) {
        Command command = Parser.getInstance().parseCommand(this,
                commandString);
        Token reserved = command.getReservedToken();
        if (commandString.isEmpty()) {
            feedback(FeedbackMessage.CLEAR);
            display();
        } else if (reserved.isEmptyToken()) {
            feedback(FeedbackMessage.ERROR_UNRECOGNIZED_COMMAND);
        } else {
            CommandHandler handler = mCommandHandlers.get(reserved.value);
            if (handler != null) {
                handler.execute(this, command);
                if (handler.shouldDisplay()) {
                    display();
                }
            }
        }
        writeTasks();
    }

    @Override
    public void display() {
        mUI.display(mTasks);
    }

    @Override
    public void feedback(FeedbackMessage m) {
        mUI.feedback(m);
    }

    @Override
    public boolean showChangeDataFilePathDialog() {
        return mUI.showChangeDataFilePathDialog();
    }

    @Override
    public boolean showHelpPage() {
        return mUI.showHelpPage();
    }

    @Override
    public void addTask(Task task) {
        mTasks.add(task);
    }

    public ArrayList<Task> getAllTasks() {
        return mTasks;
    }

    @Override
    public Task getTask(int index) throws TaskNotFoundException {
        try {
            return mTasks.get(mTasks.indexOf(mUI.getTask(index)));
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
    }

    @Override
    public Task removeTask(Task task) throws TaskNotFoundException {
        if (mTasks.remove(task)) {
            return task;
        } else {
            throw new TaskNotFoundException();
        }
    }

    @Override
    public Task removeTask(int index) throws TaskNotFoundException {
        Task task = mUI.getTask(index);
        return removeTask(task);
    }

    @Override
    public void readTasks() {
        mTasks.clear();
        mTasks.addAll(mStorage.readTasksFromDataFile());
        createUndoCommandHistory();
    }

    @Override
    public void writeTasks() {
        mStorage.writeTasksToDataFile(mTasks);
    }

    @Override
    public File getDataFile() {
        return mStorage.getDataFile();
    }

    @Override
    public void setDataFile(File newDataFile) {
        mStorage.setDataFile(newDataFile);
        readTasks();
    }

    @Override
    public void pushFilter(Filter filter) {
        mUI.pushFilter(filter);
    }

    @Override
    public Filter popFilter() {
        return mUI.popFilter();
    }

```
###### src\sg\edu\cs2103aug2015_w13_2j\LogicInterface.java
``` java

/**
 * Interface for a FunDUE logic component. Provides methods to modify the master
 * list of {@link Task} objects as well as methods to interact with the
 * {@link UIInterface} and {@link StorageInterface} components via pass-through
 * methods.
 * 
 * @author Zhu Chunqi
 */
public interface LogicInterface {
    /**
     * Injects the dependency on {@link StorageInterface} and
     * {@link UIInterface} components into this {@link LogicInterface}
     * component.
     * 
     * @param storage
     *            {@link StorageInterface} component to be used. A handle to
     *            this component will be retained for subsequent I/O method
     *            calls.
     * @param textUI
     *            {@link UIInterface} component to be used. A handle to this
     *            component will be retained for when a {@link CommandHandler}
     *            requires data to be displayed or {@link FeedbackMessage} to be
     *            shown.
     */
    public void injectDependencies(StorageInterface storage,
            UIInterface textUI);

    /**
     * Retrieves the {@link Set} of reserved keyword strings registered by
     * {@link CommandHandler} objects during FunDUE initialization.
     * 
     * @return {@link Set} of reserved keyword strings.
     * @see #registerCommandHandler(CommandHandler)
     */
    public Set<String> getReservedKeywords();

    /**
     * Retrieves the {@link HashMap} of reserved keyword strings to their
     * respective {@link CommandHandler} objects.
     * 
     * @return {@link HashMap} mapping reserved keyword strings to their
     *         respective {@link CommandHandler} objects.
     */
    public HashMap<String, CommandHandler> getCommandHandlers();

    /**
     * Registers the provided {@link CommandHandler} object with this
     * {@link LogicInterface} component. Adds all reserved keyword strings
     * retrieved via {@link CommandHandler#getReservedKeywords()} to the
     * complete set of reserved keywords and maps them to this
     * {@link CommandHandler} object.
     * 
     * @param handler
     *            {@link CommandHandler} object to be registered.
     */
    public void registerCommandHandler(CommandHandler handler);

    /**
     * Executes the command string entered by the user.
     * 
     * @param command
     *            Command string to execute.
     */
    public void executeCommand(String command);

    /**
     * Sends the master list of {@link Task} objects to the {@link UIInterface}
     * component to be displayed.
     */
    public void display();

    /**
     * Pass-through method to {@link UIInterface#feedback(FeedbackMessage)}
     * which displays the provided {@link FeedbackMessage} object to the user.
     * 
     * @param feedback
     *            {@link FeedbackMessage} object to be displayed.
     */
    public void feedback(FeedbackMessage feedback);

    /**
     * Pass-through method to {@link UIInterface#showChangeDataFilePathDialog()}
     * which shows a file picker dialog to let the user choose a new FunDUE data
     * file.
     * 
     * @return {@code True} if a file was chosen, {@code false} otherwise.
     */
    public boolean showChangeDataFilePathDialog();

    /**
     * Pass-through method to {@link UIInterface#showHelpPage()} which shows the
     * FunDUE Help Page window.
     * 
     * @return {@code True} if the FunDUE Help Page was shown, {@code false} if
     *         the window was already showing.
     */
    public boolean showHelpPage();

    /**
     * Adds the provided {@link Task} object to the master list of {@link Task}
     * objects.
     * 
     * @param task
     *            {@link Task} object to be added.
     */
    public void addTask(Task task);

    /**
     * Retrieves the master list of ({@link Task} objects existing locally in
     * the {@link Logic} component.
     * 
     * @return Master list of {@link Task} objects
     */
    public ArrayList<Task> getAllTasks();

    /**
     * Retrieves the {@link Task} object associated with the provided index from
     * the master list of {@link Task} objects. The provided index is specific
     * to the way the {@link UIInterface} component chooses to display and index
     * the master list of {@link Task} objects. Therefore,
     * {@link UIInterface#getTask(int)} is first called to retrieve the
     * {@link Task} object from the {@link UIInterface} component,
     * {@link ArrayList#indexOf(Object)} is called to retrieve the corresponding
     * index in the master list of {@link Task} objects, and finally that index
     * is used to retrieve the associated {@link Task} object from the master
     * list of {@link Task} objects.
     * 
     * @param index
     *            Index of the {@link Task} object to be retrieved.
     * @return {@link Task} object associated with the provided index.
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds.
     */
    public Task getTask(int index) throws TaskNotFoundException;

    /**
     * Removes the {@link Task} object from the master list of {@link Task}
     * objects. {@link ArrayList#remove(Object)} is called to remove the
     * {@link Task} object from the master list of {@link Task} objects.
     * 
     * @param task
     *            {@link Task} object to be removed.
     * @return {@link Task} object specified. An exception will be thrown if any
     *         provided index is out of bounds.
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds.
     */
    public Task removeTask(Task task) throws TaskNotFoundException;

    /**
     * Removes the {@link Task} object associated with the provided index from
     * the master list of {@link Task} objects. The provided index is specific
     * to the way the {@link UIInterface} component chooses to display and index
     * the master list of {@link Task} objects. Therefore,
     * {@link UIInterface#getTask(int)} is first called to retrieve the
     * {@link Task} object associated with the provided index, then
     * {@link ArrayList#remove(Object)} is called to remove the {@link Task}
     * object from the master list of {@link Task} objects.
     * 
     * @param index
     *            Integer index of the {@link Task} object to be removed.
     * @return {@link Task} object associated with the provided index. An
     *         exception will be thrown if the provided index is out of bounds.
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds.
     */
    public Task removeTask(int index) throws TaskNotFoundException;

    /**
     * Reads the master list of {@link Task} objects from the FunDUE data file
     * using the {@link StorageInterface} component. The current master list of
     * {@link Task} objects will be cleared first.
     */
    public void readTasks();

    /**
     * Writes the master list of {@link Task} objects to the FunDUE data file
     * using the {@link StorageInterface} component.
     */
    public void writeTasks();

    /**
     * Pass-through method to {@link StorageInterface#getDataFile()} which
     * retrieves the {@link File} object representing the current FunDUE data
     * file.
     * 
     * @return {@link File} object representing the current FunDUE data file.
     */
    public File getDataFile();

    /**
     * Pass-through method to {@link StorageInterface#setDataFile(File)} which
     * sets the provided {@link File} object as the new FunDUE data file.
     * 
     * @param dataFile
     *            {@link File} object to be used as the FunDUE data file.
     */
    public void setDataFile(File dataFile);

    /**
     * Pass-through method to {@link UIInterface#pushFilter(Filter)} which
     * pushes the provided {@link Filter} object onto the filter chain stack.
     * 
     * @param filter
     *            {@link Filter} object to be pushed onto the filter chain
     *            stack.
     */
    public void pushFilter(Filter filter);

    /**
     * Pass-through method to {@link UIInterface#popFilter()} which pops the top
     * most {@link Filter} object from the filter chain stack and returns it.
     * 
     * @return {@link Filter} object that was popped from the filter chain stack
     *         or {@code null} if only the root {@link Filter} is left.
     */
    public Filter popFilter();

```
###### src\sg\edu\cs2103aug2015_w13_2j\parser\Command.java
``` java

public class Command implements Iterable<Token> {
    private ArrayList<Token> mTokens = new ArrayList<Token>();

    /**
     * Adds the newly parsed Token object into this Command object
     * 
     * @param token
     *            The Token object to be added
     */
    public void addToken(Token token) {
        mTokens.add(token);
    }

    /**
     * Adds the newly parsed Token object into this Command object
     * 
     * @param type
     *            The enumerated Type of the new Token
     * @param value
     *            The String value of the new Token
     */
    public void addToken(Token.Type type, String value) {
        addToken(new Token(type, value));
    }

    /**
     * Retrieves the first ALPHA_NUM token of this command
     * 
     * @return First Token object of type ALPHA_NUM or an EMPTY Token if command
     *         contains none
     */
    public Token getAlphaToken() {
        for (Token token : this) {
            if (token.type == Type.ALPHA_NUM) {
                return token;
            }
        }
        return Token.EMPTY_TOKEN;
    }

    /**
     * Retrieves the first ID token of this command
     * 
     * @return First Token object of type ID or an EMPTY Token if command
     *         contains none
     */
    public Token getIdToken() {
        for (Token token : this) {
            if (token.type == Type.ID) {
                return token;
            }
        }
        return Token.EMPTY_TOKEN;
    }

    /**
     * Convenience method to retrieves a list of all values of ID tokens in this
     * command
     * 
     * @return List of all values of objects of type ID or an empty list if
     *         command contains none
     */
    public ArrayList<Integer> getAllIdTokenValues() {
        ArrayList<Integer> idTokens = new ArrayList<Integer>();
        for (Token token : this) {
            if (token.type == Type.ID) {
                idTokens.add(Integer.parseInt(token.value));
            }
        }
        return idTokens;
    }

    /**
     * Retrieves the first RESERVED token of this command
     * 
     * @return First Token object of type RESERVED or an EMPTY Token if command
     *         contains none
     */
    public Token getReservedToken() {
        for (Token token : this) {
            if (token.type == Type.RESERVED) {
                return token;
            }
        }
        return Token.EMPTY_TOKEN;
    }

    /**
     * Removes and returns the first instance of a RESERVED {@link Token} object
     * of this command.
     * 
     * @return First RESERVED {@link Token} object or an EMPTY {@link Token}
     *         object if command contains none.
     */
    public Token removeReservedToken() {
        Iterator<Token> iter = mTokens.iterator();
        while (iter.hasNext()) {
            Token token = iter.next();
            if (token.type == Type.RESERVED) {
                iter.remove();
                return token;
            }
        }
        return Token.EMPTY_TOKEN;
    }

    @Override
    public Iterator<Token> iterator() {
        return mTokens.iterator();
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\parser\Parser.java
``` java

/**
 * Parser class that handles the interpretation of tokens within the user's
 * command input. This class ensures that all tokens of the user command are of
 * a specific {@link Token} type.
 * 
 * @author Zhu Chunqi
 */
public class Parser {
    public static final String FLAG_END = "e";
    public static final String FLAG_START = "s";
    public static final String DATETIME_FORMAT_STRING = "dd_MM_yyyy_HH_mm";
    public static final String[] FLAGS = { FLAG_END, FLAG_START };
    public static final String[] DATETIME_FORMAT_PARTS = { "dd", "MM", "yyyy",
            "0", "0" };
    public static final SimpleDateFormat DATETIME_FORMAT = new SimpleDateFormat(
            "dd_MM_yyyy_HH_mm");

    private static final Logger LOGGER = Logger
            .getLogger(Parser.class.getName());

    private enum State {
        GENERAL, ALPHA_NUM, DATE, FLAG, ID, NAME
    }

    private static Parser sInstance;

    private Set<String> mReserved;
    private State mState;
    private String mCommandString;
    private Command mCommand;
    private int mParserPos;

    /**
     * Private constructor.
     */
    private Parser() {
        // Do nothing
    }

    /**
     * Retrieves the singleton instance of this {@link Parser} component.
     * 
     * @return {@link Parser} component.
     */
    public static synchronized Parser getInstance() {
        if (sInstance == null) {
            sInstance = new Parser();
        }
        return sInstance;
    }

    /**
     * Parses the provided command string into a {@link Command} object. Invalid
     * tokens are marked with _INVALID after the {@link Token} type.
     * 
     * @param logic
     *            Dependency injection of a {@link LogicInterface} component
     *            which is used by this {@link Parser} component to determine
     *            the reserved keyword strings.
     * @param command
     *            Command string to parse.
     * @return A {@link Iterable} {@link Command} object containing parsed
     *         {@link Token}s.
     */
    public Command parseCommand(Logic logic, String command) {
        mReserved = logic.getReservedKeywords();
        mState = State.GENERAL;
        mParserPos = 0;
        mCommand = new Command();
        mCommandString = command;
        startParserLoop();
        LOGGER.log(Level.INFO, getParsedTokens());
        return mCommand;
    }

    /**
     * Retrieves a string in the format of {@code [token1=value][token2=value]}
     * etc. representing the parsed {@link Token}s.
     * 
     * @return String of parsed {@link Token}s.
     */
    public String getParsedTokens() {
        StringBuilder sb = new StringBuilder();
        for (Token token : mCommand) {
            sb.append('[');
            sb.append(token.type);
            if (token.value != null) {
                sb.append('=');
                sb.append(token.value);
            }
            sb.append(']');
        }
        return sb.toString();
    }

    /**
     * Attempts to parse the provided date string and return a string
     * representation in the format dd_MM_yyyy_HH_mm to be used by
     * {@link SimpleDateFormat} to fill the unspecified parts from a base date.
     * Supported date string formats are any combination of date and time
     * formats as listed below. An exception will be thrown if the provided date
     * string does not conform to any supported format. Bounds checking is
     * <b>not</b> performed for day, month, year, hour or minute values.
     * <ul>
     * <li>dd/mm/yyyy</li>
     * <li>dd/mm</li>
     * <li>dd</li>
     * <li>Thh:mm</li>
     * <li>Thh</li>
     * </ul>
     * 
     * @param datetime
     *            Date string to be parsed.
     * @return String in the format {@code dd_MM_yyyy_HH_mm}. Fields which are
     *         defined in the date string are filled in.
     * @throws IllegalDateFormatException
     *             Thrown when the date string is not of a valid format.
     */
    public static String parseDate(String datetime)
            throws IllegalDateFormatException {
        int[] parts = { -1, -1, -1, -1, -1 };
        String[] stringSplit = datetime.split("T", 2);
        String[] dateSplit = stringSplit[0].split("/", 3);
        try {
            // Parse date components
            if (stringSplit[0].length() > 0) {
                for (int i = 0; i < 3 && i < dateSplit.length; i++) {
                    parts[i] = Integer.parseInt(dateSplit[i]);
                }
            }
            if (stringSplit.length == 2 && stringSplit[1].length() > 0) {
                // Parse time components
                String[] timeSplit = stringSplit[1].split(":", 2);
                for (int i = 0; i < 2 && i < timeSplit.length; i++) {
                    parts[i + 3] = Integer.parseInt(timeSplit[i]);
                }
            }
        } catch (NumberFormatException e) {
            throw new IllegalDateFormatException();
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            sb.append((parts[i] == -1 ? DATETIME_FORMAT_PARTS[i]
                    : String.valueOf(parts[i])));
            if (i < parts.length - 1) {
                sb.append('_');
            }
        }
        return sb.toString();
    }

    /**
     * Attempts to update the fields of the provided base {@link Date} to match
     * that in the format string. Throws an exception when the format string
     * contains values which are out of bounds for their corresponding fields.
     * 
     * @param format
     *            String of the format {@code dd_MM_yyyy_HH_mm} as produced by
     *            {@link #parseDate(String)}.
     * @param baseDate
     *            Base {@link Date} object to be updated, does not check for
     *            {@code null}.
     * @return Updated {@link Date} object if there were no parse errors or the
     *         original {@link Date} object otherwise.
     */
    public static Date updateDate(String format, Date baseDate) {
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        LOGGER.log(Level.FINE, "Base date: " + baseDate);
        String updated = formatter.format(baseDate);
        LOGGER.log(Level.FINE, "Updated: " + updated);
        try {
            return DATETIME_FORMAT.parse(updated);
        } catch (ParseException e) {
            return baseDate;
        }
    }

    /**
     * Main loop of the {@link Parser} state machine.
     */
    private void startParserLoop() {
        // Buffer to store parsed tokens
        String s;
        char openingQuote = '"';

        while (hasNext()) {
            if (!trim()) {
                break;
            }

            switch (mState) {
              case ALPHA_NUM :
                s = nextDelimiter(' ');
                if (isReserved(s)) {
                    mCommand.addToken(Token.Type.RESERVED, s);
                } else {
                    mCommand.addToken(Token.Type.ALPHA_NUM, s);
                }
                mState = State.GENERAL;
                break;
              case DATE :
                s = nextDelimiter(' ');
                try {
                    String dateString = Parser.parseDate(s);
                    mCommand.addToken(Token.Type.DATE, dateString);
                } catch (IllegalDateFormatException e) {
                    mCommand.addToken(Token.Type.DATE_INVALID, s);
                }
                mState = State.GENERAL;
                break;
              case FLAG :
                // Consume dash character
                next();
                s = nextDelimiter(' ');

                // Check if flag is valid and add token
                if (isValidFlag(s)) {
                    mCommand.addToken(Token.Type.FLAG, s);
                    // TODO: May not always transition to date state
                    mState = State.DATE;
                } else {
                    mCommand.addToken(Token.Type.FLAG_INVALID, s);
                    mState = State.GENERAL;
                }
                break;
              case GENERAL :
                if (peek() == ' ') {
                    // Skip over all intervening whitespace
                    while (hasNext() && peek() == ' ') {
                        next();
                    }
                } else if (peek() == '"' || peek() == '\'') {
                    openingQuote = next();
                    mState = State.NAME;
                } else if (peek() == '-') {
                    mState = State.FLAG;
                } else if (peek() >= '0' && peek() <= '9') {
                    mState = State.ID;
                } else {
                    mState = State.ALPHA_NUM;
                }
                break;
              case ID :
                s = nextDelimiter(' ');
                try {
                    Integer.parseInt(s);
                    mCommand.addToken(Token.Type.ID, s);
                } catch (NumberFormatException e) {
                    // e.printStackTrace();
                    mCommand.addToken(Token.Type.ID_INVALID, s);
                }
                mState = State.GENERAL;
                break;
              case NAME :
                s = nextDelimiter(openingQuote);
                mCommand.addToken(Token.Type.NAME, s);
                // Consume closing quote if not end of command
                if (hasNext()) {
                    next();
                }
                mState = State.GENERAL;
                break;
              default :
                throw new Error("Invalid parser state: " + mState);
            }
        }
    }

    /**
     * Checks if the end of the command string has been reached
     * 
     * @return {@code True} if there are more characters to read, {@code false}
     *         otherwise.
     */
    private boolean hasNext() {
        return mParserPos < mCommandString.length();
    }

    /**
     * Retrieves the next character of the command string without advancing the
     * parser position.
     * 
     * @return Next character of the command string.
     */
    private char peek() {
        return mCommandString.charAt(mParserPos);
    }

    /**
     * Retrieves the next character of the command and advances the parser one
     * position forward.
     * 
     * @return Next character of the command string.
     */
    private char next() {
        return mCommandString.charAt(mParserPos++);
    }

    /**
     * Reads the command string character by character until the provided
     * delimiter or end of command string is encountered. Returns the characters
     * read as a string.
     * 
     * @param delimiter
     *            Character delimiter to stop reading when encountered.
     * @return String read from the current parser position until the delimiter
     *         or end of the command string is encountered.
     */
    private String nextDelimiter(char delimiter) {
        StringBuilder sb = new StringBuilder();
        while (hasNext() && peek() != delimiter) {
            sb.append(next());
        }
        return sb.toString();
    }

    /**
     * Advances the parser position to the next non-whitespace character and
     * returns the value of {@link #hasNext()}.
     * 
     * @return Value of {@link #hasNext()}.
     */
    private boolean trim() {
        if (hasNext() && peek() == ' ') {
            while (hasNext() && peek() == ' ') {
                next();
            }
        }
        return hasNext();
    }

    /**
     * Checks if the provided string is a reserved keyword in a case
     * <b>insensitive</b> manner. The provided string is first converted to all
     * lower case before the comparison is carried out.
     * 
     * @param s
     *            String to be checked.
     * @return {@code True} if the string is a reserved keyword, {@code false}
     *         otherwise.
     */
    private boolean isReserved(String s) {
        return mReserved.contains(s.toLowerCase());
    }

    /**
     * Checks if the provided string is a valid flag in a case
     * <b>insensitive</b> manner. The provided string is first converted to all
     * lower case before the comparison is carried out.
     * 
     * @param s
     *            String to be checked
     * @return {@code True} if the string is a valid flag, {@code false}
     *         otherwise.
     */
    private boolean isValidFlag(String flag) {
        return Arrays.asList(FLAGS).contains(flag.toLowerCase());
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\parser\ParserTest.java
``` java

public class ParserTest {
    private static final Logger LOGGER = Logger
            .getLogger(ParserTest.class.getName());
    private Parser mParser = Parser.getInstance();
    private Logic mLogic = (Logic) Logic.getInstance();

    @BeforeClass
    public static void setup() {
        Logic.getInstance().registerCommandHandler(new AddHandler());
    }

    /**
     * Compares the expected string of parsed tokens from parsing the provided
     * command string to the actual string of parsed tokens
     * 
     * @param command
     *            Command string to parse
     * @param expected
     *            Expected string of parsed tokens
     */
    private void testCommandParser(String command, String expected) {
        LOGGER.log(Level.INFO, "Parsing: " + command);
        mParser.parseCommand(mLogic, command);
        LOGGER.log(Level.INFO, "Parsed Tokens: " + mParser.getParsedTokens());
        LOGGER.log(Level.INFO, "Expected: " + expected);
        assertEquals(expected, mParser.getParsedTokens());
    }

    private void testDatetimeParser(String datetime, String expected)
            throws IllegalDateFormatException {
        LOGGER.log(Level.INFO, "Parsing: " + datetime);
        String actual = Parser.parseDate(datetime);
        LOGGER.log(Level.INFO, "Parsed datetime: " + actual);
        LOGGER.log(Level.INFO, "Expected: " + expected);
        assertEquals(expected, actual);
    }

    @Test
    public void parserTokenizerTest() {
        String command = "add -s 23/09 -e 4pm *@(*#(!&@! 'Task name'";
        String expected = "[RESERVED=add][FLAG=s][DATE=23_9_yyyy_0_0]"
                + "[FLAG=e][DATE_INVALID=4pm][ALPHA_NUM=*@(*#(!&@!]"
                + "[NAME=Task name]";

        testCommandParser(command, expected);
    }

    @Test
    public void parserDateTimeFormatsTest() throws IllegalDateFormatException {
        testDatetimeParser("23/09/2015T10:11", "23_9_2015_10_11");
        testDatetimeParser("23/09/2015T10", "23_9_2015_10_0");
        testDatetimeParser("23/09/2015", "23_9_2015_0_0");
        testDatetimeParser("23/09T10:11", "23_9_yyyy_10_11");
        testDatetimeParser("23/09T10", "23_9_yyyy_10_0");
        testDatetimeParser("23/09", "23_9_yyyy_0_0");
        testDatetimeParser("23T10:11", "23_MM_yyyy_10_11");
        testDatetimeParser("23T10", "23_MM_yyyy_10_0");
        testDatetimeParser("23", "23_MM_yyyy_0_0");
    }

    @Test
    public void parseCommandTest() {
        // Equivalence partition for case of 'Valid command Token'
        // These are cases where a valid command is recognized:
        // 1.) Valid first token and random symbols
        // 2.) Single token that is, itself, a valid keyword
        String correctCommand = "add **(#!(ab*@&#!(@&";
        String correctCommandExpected = "[RESERVED=add][ALPHA_NUM=**(#!(ab*@&#!(@&]";
        String singleTokenCommand = "add";
        String singleTokenCommandExpected = "[RESERVED=add]";

        testCommandParser(correctCommand, correctCommandExpected);
        testCommandParser(singleTokenCommand, singleTokenCommandExpected);

        // Equivalence partitions for cases of 'Invalid command Token'
        // These are cases where an invalid command is found:
        // 1.) Invalid command spelling
        // 2.) Incorrect number of tokens
        String incorrectKeywordCommand = "addd *(&(!*&@*!*(@&(";
        String incorrectKeywordCommandExpected = "[ALPHA_NUM=addd]"
                + "[ALPHA_NUM=*(&(!*&@*!*(@&(]";
        String singleTokenIncorrectKeywordCommand = "adzzd";
        String singleTokenIncorrectKeywordCommandExpected = "[ALPHA_NUM=adzzd]";
        String emptyCommand = "";
        String emptyCommandExpected = "";

        testCommandParser(incorrectKeywordCommand,
                incorrectKeywordCommandExpected);
        testCommandParser(singleTokenIncorrectKeywordCommand,
                singleTokenIncorrectKeywordCommandExpected);
        testCommandParser(emptyCommand, emptyCommandExpected);
    }

    /*****************************************************************
     * TESTING PARSE TASK NAME METHODS
     *****************************************************************/
    @Test
    public void parseTaskNameTest() {
        // Equivalence partition for a 'Valid task name'
        // These are test cases for a valid task name recognized:
        // 1.) Test with enclosing wrappers single quote ' and double quote "
        // 2.) Test with task names that are integers with enclosing wrappers
        // 3.) Test with no closing wrapper single quote ' or double quote "
        String validTaskName = "'Eat Lunch'";
        String validTaskNameExpected = "[NAME=Eat Lunch]";
        String validTaskNameAlternative = "\"Eat Lunch\"";
        String validTaskNameAlternativeExpected = "[NAME=Eat Lunch]";
        String validNumericTaskName = "'12345'";
        String validNumericTaskNameExpected = "[NAME=12345]";
        String noClosingWrapper = "'Eat Lunch";
        String noClosingWrapperExpected = "[NAME=Eat Lunch]";

        testCommandParser(validTaskName, validTaskNameExpected);
        testCommandParser(validTaskNameAlternative,
                validTaskNameAlternativeExpected);
        testCommandParser(validNumericTaskName, validNumericTaskNameExpected);
        testCommandParser(noClosingWrapper, noClosingWrapperExpected);

        // Equivalence partition for an 'Invalid task name'
        // These are test cases for a task name with incomplete/unaccepted
        // wrappers:
        // 1.) Test with an absence of both opening and closing wrappers with
        // letters as names
        // 2.) Test with an absence of both opening and closing wrappers with
        // integers as names
        // 3.) Test with an absence of opening wrapper
        String noWrappers = "Eat Lunch";
        String noWrappersExpected = "[ALPHA_NUM=Eat][ALPHA_NUM=Lunch]";
        String numericTaskName = "12345";
        String numericTaskNameExpected = "[ID=12345]";
        String noOpeningWrapper = "Eat Lunch'";
        String noOpeningWrapperExpected = "[ALPHA_NUM=Eat][ALPHA_NUM=Lunch']";

        testCommandParser(noWrappers, noWrappersExpected);
        testCommandParser(numericTaskName, numericTaskNameExpected);
        testCommandParser(noOpeningWrapper, noOpeningWrapperExpected);
    }

    /*****************************************************************
     * TESTING PARSE OPTIONS IN COMMANDLINE METHODS
     *****************************************************************/
    @Test
    public void parseAllOptionsTest() {
        // Equivalence partition for an 'Valid option(s)'
        // These are test cases for valid flag-date pairs recognized:
        // 1.) Test with single valid option
        // 2.) Test with multiple valid options
        // 3.) Test with empty option field
        String singleValidOption = "-s 23/09";
        String singleValidOptionExpected = "[FLAG=s][DATE=23_9_yyyy_0_0]";
        String validOptions = "-s 23/09 -e 24/09";
        String validOptionsExpected = "[FLAG=s][DATE=23_9_yyyy_0_0]"
                + "[FLAG=e][DATE=24_9_yyyy_0_0]";
        String emptyToken = "";
        String emptyTokenExpected = "";

        testCommandParser(singleValidOption, singleValidOptionExpected);
        testCommandParser(validOptions, validOptionsExpected);
        testCommandParser(emptyToken, emptyTokenExpected);

        // Equivalence partition for 'Invalid option(s)'
        // These are test cases for invalid flag-date pairs recognized:
        // 1.) Test with flag but no specified date
        // 2.) Test with a date that is not attached to any flag/option
        // 3.) Test with a single valid flag-date pair, followed by
        // a flag with no specified date
        String singleToken = "-s";
        String singleTokenExpected = "[FLAG=s]";
        String invalidSecondOption = "-s 23/09 24/09 -e 25/09";
        String invalidSecondOptionExpected = "[FLAG=s][DATE=23_9_yyyy_0_0]"
                + "[ID_INVALID=24/09][FLAG=e]" + "[DATE=25_9_yyyy_0_0]";
        String invalidSecondOptionField = "-s 23/09 -e";
        String invalidSecondOptionFieldExpected = "[FLAG=s]"
                + "[DATE=23_9_yyyy_0_0][FLAG=e]";

        testCommandParser(singleToken, singleTokenExpected);
        testCommandParser(invalidSecondOption, invalidSecondOptionExpected);
        testCommandParser(invalidSecondOptionField,
                invalidSecondOptionFieldExpected);

        // Equivalence partition for 'Invalid flag(s)'
        // These are test cases for invalid flags recognized
        // 1.) Test with flag with wrong spelling
        // 2.) Test with flag with wrong spelling, followed by a date
        // 3.) Test with flag followed by a task name instead of a valid date
        String singleInvalidToken = "-ss";
        String singleInvalidTokenExpected = "[FLAG_INVALID=ss]";
        String invalidOptionWithField = "-ss 23/09";
        String invalidOptionWithFieldExpected = "[FLAG_INVALID=ss]"
                + "[ID_INVALID=23/09]";
        String invalidFlagThenTaskName = "add -s 'Do Homework'";
        String invalidFlagThenTaskNameExpected = "[RESERVED=add]"
                + "[FLAG=s][DATE_INVALID='Do]" + "[ALPHA_NUM=Homework']";

        testCommandParser(singleInvalidToken, singleInvalidTokenExpected);
        testCommandParser(invalidOptionWithField,
                invalidOptionWithFieldExpected);
        testCommandParser(invalidFlagThenTaskName,
                invalidFlagThenTaskNameExpected);
    }

    @Test
    public void parserRegression119Test() {
        // Parser NullPointerException when no date is provided
        String command = "a 'lunch with someone' -s ''";
        String commandExpected = "[RESERVED=a][NAME=lunch with someone][FLAG=s][DATE_INVALID='']";
        testCommandParser(command, commandExpected);
    }

    @Test
    public void parserRegression126Test() {
        // Parser IndexOutOfBoundsException when parser position advances past
        // end of command due to trim()
        String command = "add  ";
        String commandExpected = "[RESERVED=add]";
        testCommandParser(command, commandExpected);
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\parser\Token.java
``` java

/**
 * Utility class that represents a parsed token and its corresponding value
 * 
 * @author Zhu Chunqi
 */
public class Token {
    public static final Token EMPTY_TOKEN = new Token(Type.EMPTY, "");

    public enum Type {
        EMPTY, RESERVED, DATE, DATE_INVALID, FLAG, FLAG_INVALID, ID, ID_INVALID, NAME, WHITESPACE, ALPHA_NUM;
    };

    public Type type;
    public String value;

    public Token(Type type, String value) {
        this.type = type;
        this.value = value;
    }

    public boolean isEmptyToken() {
        return this.type.equals(Token.Type.EMPTY);
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\storage\StorageStub.java
``` java

/**
 * {@link StorageInterface} component for testing purposes. Stores {@link Task}
 * objects in memory and does <b>not</b> read from or write to disk.
 */
public class StorageStub implements StorageInterface {
    private final ArrayList<Task> mStorage = new ArrayList<Task>();

    private static StorageInterface sInstance;

    /**
     * Private constructor.
     */
    private StorageStub() {
        // Do nothing
    }

    /**
     * Retrieves the single instance of this {@link StorageInterface} component.
     * 
     * @return {@link StorageInterface} component.
     */
    public static synchronized StorageInterface getInstance() {
        if (sInstance == null) {
            sInstance = new StorageStub();
        }
        return sInstance;
    }

    @Override
    public ArrayList<Task> readTasksFromDataFile() {
        return mStorage;
    }

    @Override
    public void writeTasksToDataFile(ArrayList<Task> tasks) {
        mStorage.clear();
        mStorage.addAll(tasks);
    }

    @Override
    public File getDataFile() {
        return null;
    }

    @Override
    public void setDataFile(File newDataFile) {
        // Do nothing
    }

    @Override
    public void clearDataFile() {
        mStorage.clear();
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\Task.java
``` java

/**
 * The Task class encapsulates all the data that represents a task: for example
 * the name, deadline etc. Also provides getter and setter methods to manipulate
 * named built-in attributes.
 * 
 * @author Zhu Chunqi
 */
public class Task implements Comparable<Task>, Cloneable {
    public enum Type {
        DEADLINE, EVENT, FLOATING
    }

    public static final String TRUE_VALUE = "TRUE";
    public static final String FALSE_VALUE = "FALSE";
    public static final String LABEL_COMPLETED = "COMPLETED";
    public static final String LABEL_CREATED = "CREATED";
    public static final String LABEL_END = "END";
    public static final String LABEL_IMPORTANT = "IMPORTANT";
    public static final String LABEL_NAME = "NAME";
    public static final String LABEL_START = "START";
    public static final String LABEL_TYPE = "TYPE";

    private final HashMap<String, String> mLabels = new HashMap<String, String>();

    /**
     * Zero parameter constructor that creates and initializes a new
     * {@link Task} object and records the time of creation. Note that the
     * {@link Task} object is <b>invalid</b> as no name has been set.
     */
    public Task() {
        setLabel(LABEL_CREATED, String.valueOf(System.currentTimeMillis()));
    }

    /**
     * Constructor to create a new {@link Task} object and set the name as the
     * string provided. Internally creates a new {@link Task} object and calls
     * {@link Task#setName(String)}.
     * 
     * @param name
     *            String name to give this {@link Task} object.
     */
    public Task(String name) {
        this();
        assert (this.getCreated() != null);
        setName(name);
    }

    /**
     * Sets the string value of the specified label of this {@link Task} object.
     * 
     * @param label
     *            Label value to set.
     * @param value
     *            String value to set the label or {@code null} to unset the
     *            label.
     */
    public void setLabel(String label, String value) {
        mLabels.put(label, value);
    }

    /**
     * Retrieves the string value of the specified label of this {@link Task}
     * object.
     * 
     * @param label
     *            Label value to retrieve.
     * @return String value of the specified label or {@code null} if the label
     *         was not previously set.
     */
    public String getLabel(String label) {
        return mLabels.get(label);
    }

    /**
     * Sets the string value of the {@value #LABEL_NAME} label of this
     * {@link Task} object.
     * 
     * @param name
     *            String value to set the {@value #LABEL_NAME} label.
     */
    public void setName(String name) {
        setLabel(LABEL_NAME, name);
    }

    /**
     * Retrieves the string value of the {@value #LABEL_NAME} label of this
     * {@link Task} object.
     * 
     * @return String value of the {@value #LABEL_NAME} label or {@code null} if
     *         not previously set.
     */
    public String getName() {
        return getLabel(LABEL_NAME);
    }

    /**
     * Retrieves a {@link Date} representation the {@value #LABEL_CREATED} label
     * of this {@link Task} object.
     * 
     * @return {@link Date} representation of the {@value #LABEL_CREATED} label.
     */
    public Date getCreated() {
        return stringToDate(getLabel(LABEL_CREATED));
    }

    /**
     * Sets the value of the {@value #LABEL_START} label of this {@link Task}
     * object by converting the provided {@link Date} object into the string
     * millisecond epoch.
     * 
     * @param start
     *            {@link Date} value to set the {@value #LABEL_START} or
     *            {@code null} to unset the label.
     */
    public void setStart(Date start) {
        setLabel(LABEL_START, dateToString(start));
    }

    /**
     * Sets the value of the {@value #LABEL_START} label of this {@link Task}
     * object based on the current value of the {@value #LABEL_START} label as
     * well as the provided format string. If the {@value #LABEL_START} label
     * has been set previously, its value will be used as the base date from
     * which the unspecified parts of the format string are derived. Otherwise,
     * the current date and time will be used as the base date instead.
     * 
     * @param format
     *            Format string of the form {@code dd_MM_yyyy_HH_mm} where one
     *            or more parts may be specified by user input.
     */
    public void setStart(String format) {
        Date startDate = getStart();
        startDate = updateDate(format, startDate);
        setStart(startDate);
    }

    /**
     * Retrieves a {@link Date} representation of the {@value #LABEL_START}
     * label of this {@link Task} object.
     * 
     * @return {@link Date} representation of the {@value #LABEL_START} label.
     */
    public Date getStart() {
        return stringToDate(getLabel(LABEL_START));
    }

    /**
     * Sets the value of the {@value #LABEL_END} label of this {@link Task}
     * object by converting the provided {@link Date} object into the string
     * millisecond epoch.
     * 
     * @param start
     *            {@link Date} value to set the {@value #LABEL_END} or
     *            {@code null} to unset the label.
     */
    public void setEnd(Date end) {
        setLabel(LABEL_END, dateToString(end));
    }

    /**
     * Sets the value of the {@value #LABEL_END} label of this {@link Task}
     * object based on the current value of the {@value #LABEL_END} label as
     * well as the provided format string. If the {@value #LABEL_END} label has
     * been set previously, its value will be used as the base date from which
     * the unspecified parts of the format string are derived. Otherwise, the
     * current date and time will be used as the base date instead.
     * 
     * @param format
     *            Format string of the form {@code dd_MM_yyyy_HH_mm} where one
     *            or more parts may be specified by user input.
     */
    public void setEnd(String format) {
        Date endDate = getEnd();
        endDate = updateDate(format, endDate);
        setEnd(endDate);
    }

    /**
     * Retrieves a {@link Date} representation of the {@value #LABEL_END} label
     * of this {@link Task} object.
     * 
     * @return {@link Date} representation of the {@value #LABEL_END} label.
     */
    public Date getEnd() {
        return stringToDate(getLabel(LABEL_END));
    }

    /**
     * Sets the enumerated {@link Type} of this {@link Task} object.
     * 
     * @param type
     *            Enumerated {@link Task} {@link Type}.
     */
    public void setType(Type type) {
        setLabel(LABEL_TYPE, type.toString());
    }

    /**
     * Retrieves the enumerated {@link Type} of this {@link Task} object.
     * 
     * @return Enumerated {@link Task} {@link Type}.
     */
    public String getType() {
        if (this.getEnd() == null) {
            return "FLOAT";
        } else {
            if (this.getStart() != null) {
                return "EVENT";
            } else {
                return "DEADLINE";
            }
        }
    }

    /**
     * Sets the boolean value of the {@value #LABEL_COMPLETED} label of this
     * {@link Task} object.
     * 
     * @param completed
     *            Boolean value to set the {@value #LABEL_COMPLETED} label.
     */
    public void setCompleted(boolean completed) {
        setBooleanValue(LABEL_COMPLETED, completed);
    }

    /**
     * Retrieves the boolean value of the {@value #LABEL_COMPLETED} label of
     * this {@link Task} object.
     * 
     * @return Boolean value of the {@value #LABEL_COMPLETED} label or
     *         {@code false} if not previously set.
     */
    public boolean isCompleted() {
        return getBooleanValue(LABEL_COMPLETED);
    }

    /**
     * Sets the boolean value of the {@value #LABEL_IMPORTANT} label of this
     * {@link Task} object.
     * 
     * @param important
     *            Boolean value to set the {@value #LABEL_IMPORTANT} label.
     */
    public void setImportant(boolean important) {
        setBooleanValue(LABEL_IMPORTANT, important);
    }

    /**
     * Retrieves the boolean value of the {@value #LABEL_IMPORTANT} label of
     * this {@link Task} object.
     * 
     * @return Boolean value of the {@value #LABEL_IMPORTANT} label or
     *         {@code false} if not previously set.
     */
    public boolean isImportant() {
        return getBooleanValue(LABEL_IMPORTANT);
    }

    /**
     * Checks if the {@link Date} value of the {@value #LABEL_END} label of this
     * {@link Task} object has passed.
     * 
     * @return {@code True} if the {@value #LABEL_END} label {@link Date} has
     *         passed, {@code false} otherwise.
     */
    public boolean isOverdue() {
        Date deadline = getEnd();
        if (deadline == null) {
            return false;
        } else {
            if (deadline.compareTo(new Date()) < 0) {
                return true;
            } else {
                return false;
            }
        }
    }

    /**
     * Checks if this {@link Task} object is valid, i.e. its
     * {@value #LABEL_NAME} label has been set with a string of non-zero length.
     * Otherwise, an exception will be thrown.
     * 
     * @return {@code True} if this {@link Task} object is valid, {@code false}
     *         otherwise.
     * @throws InvalidTaskException
     *             Thrown when this {@link Task} object is invalid, i.e. it does
     *             not have a non-zero length value set for its
     *             {@value #LABEL_NAME} label.
     */
    public boolean isValid() throws InvalidTaskException {
        if (getName() == null || getName().length() == 0) {
            throw new InvalidTaskException();
        } else {
            return true;
        }
    }

    /**
     * Checks if two {@link Task} objects are equal to each other. Specifically
     * it is assumed that each {@link Task} object is created at a different
     * point in time and their {@value #LABEL_CREATED} labels are compared for
     * equality. If their {@value #LABEL_CREATED} labels the same then their
     * {@value #LABEL_NAME} labels will be compared for equality.
     */
    @Override
    public boolean equals(Object o) {
        if (o instanceof Task) {
            String c1 = ((Task) o).getLabel(LABEL_CREATED);
            String c2 = this.getLabel(LABEL_CREATED);
            if (c1 == null && c2 == null) {
                return false;
            } else if (c1 == null && c2 != null || c1 != null && c2 == null) {
                return false;
            } else if (c1.equals(c2)) {
                String n1 = ((Task) o).getName();
                String n2 = this.getName();
                if (n1 == null && n2 == null) {
                    return true;
                } else if (n1 == null && n2 != null
                        || n1 != null && n2 == null) {
                    return false;
                } else {
                    return n1.equals(n2);
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * The hash code for this {@link Task} object is the hash code of the long
     * value of the {@value #LABEL_CREATED} label.
     * 
     * @return Hash code of this {@link Task} object.
     */
    @Override
    public int hashCode() {
        try {
            Long created = Long.parseLong(getLabel(LABEL_CREATED));
            return created.hashCode();
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    /**
     * Creates and returns a deep copy of this {@link Task} object.
     */
    @Override
    public Task clone() {
        Task task = new Task(getName());
        for (String label : mLabels.keySet()) {
            task.setLabel(label, task.getLabel(label));
        }
        return task;
    }

    /**
     * Converts the provided {@link Task} object into its string representation.
     * 
     * @return String representation of this {@link Task} object.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Entry<String, String> entry : mLabels.entrySet()) {
            sb.append(entry.getKey());
            sb.append(":");
            sb.append(entry.getValue());
            sb.append("\n");
        }
        return sb.toString();
    }

    /**
     * Converts and concatenates the provided list of {@link Task} objects into
     * their string representation with blank lines as separator.
     * 
     * @param tasks
     *            List of {@link Task} objects.
     * @return String representation of the provided list of {@link Task}
     *         objects.
     */
    public static String toString(ArrayList<Task> tasks) {
        StringBuilder sb = new StringBuilder();
        for (Task task : tasks) {
            sb.append(task.toString());
            sb.append("\n");
        }
        return sb.toString();
    }

```
###### src\sg\edu\cs2103aug2015_w13_2j\Task.java
``` java

    /**
     * Convert the string representation of the millisecond epoch into a
     * {@link Date} object.
     * 
     * @param dateString
     *            String representation of the millisecond epoch.
     * @return {@link Date} object representation of the string millisecond
     *         epoch or {@code null} if the string passed is not a valid long or
     *         is {@code null}.
     */
    private Date stringToDate(String dateString) {
        if (dateString == null) {
            return null;
        } else {
            try {
                return new Date(Long.parseLong(dateString));
            } catch (NumberFormatException e) {
                return null;
            }
        }
    }

    /**
     * Converts the {@link Date} object into a string representing the
     * millisecond epoch.
     * 
     * @param date
     *            {@link Date} object to be converted.
     * @return String representation of the millisecond epoch or {@code null} if
     *         the provided {@link Date} object is {@code null}.
     */
    private String dateToString(Date date) {
        if (date == null) {
            return null;
        } else {
            return String.valueOf(date.getTime());
        }
    }

    /**
     * Returns the boolean value of the specified label. The value of the
     * specified label is assumed to be equal to either {@value #TRUE_VALUE} or
     * {@value #FALSE_VALUE}.
     * 
     * @param label
     *            Label to retrieve the boolean value.
     * @return {@code True} if the label has been set and the value is equal to
     *         {@value #TRUE_VALUE}, {@code false} if the label was not
     *         previously set or the value is equal to {@value #FALSE_VALUE}.
     */
    private boolean getBooleanValue(String label) {
        String value = getLabel(label);
        if (value == null || value.compareTo(FALSE_VALUE) == 0) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Sets the boolean value of the specified label. The value of the label is
     * set to either {@value #TRUE_VALUE} or {@value #FALSE_VALUE} corresponding
     * to the boolean parameter.
     * 
     * @param label
     *            Label to set the boolean value.
     * @param value
     *            Boolean value to set the specified label.
     */
    private void setBooleanValue(String label, boolean value) {
        if (value) {
            setLabel(label, TRUE_VALUE);
        } else {
            setLabel(label, FALSE_VALUE);
        }
    }

    /**
     * Pass-through method to {@link ParserInterface#updateDate(String, Date)}
     * which updates the {@link Date} provided based on the format string.
     * 
     * @param format
     *            Format string of the form {@code dd_MM_yyyy_HH_mm} where one
     *            or more parts may be specified by user input.
     * @param date
     *            Base {@link Date} from which the unspecified parts of the
     *            format string are derived. If {@code null}, the current date
     *            time will be used instead.
     * @return Updated {@link Date} object.
     */
    private Date updateDate(String format, Date date) {
        if (date == null) {
            date = new Date();
        }
        return Parser.updateDate(format, date);
    }

```
###### src\sg\edu\cs2103aug2015_w13_2j\ui\FeedbackMessage.java
``` java

/**
 * FeedbackMessage class encapsulates the data necessary to display styled
 * feedback messages to the user. It comprises a message string retrievable via
 * {@link #getMessage()} and a {@link FeedbackType} object which determines the
 * type of feedback as well as the styling.
 * 
 * @author Zhu Chunqi
 */
public class FeedbackMessage {
    public static final FeedbackMessage CLEAR = new FeedbackMessage("",
            FeedbackType.INFO);
    public static final FeedbackMessage ERROR_INVALID_FILTER = new FeedbackMessage(
            "The filter that you have specified is not valid. Did you type the filter name correctly?",
            FeedbackType.ERROR);
    public static final FeedbackMessage ERROR_INVALID_TASK = new FeedbackMessage(
            "Invalid task entered. Please provide a name!", FeedbackType.ERROR);
    public static final FeedbackMessage ERROR_TASK_NOT_FOUND = new FeedbackMessage(
            "Task not found. Did you enter the index correctly?",
            FeedbackType.ERROR);
    public static final FeedbackMessage ERROR_INVALID_INDEX = new FeedbackMessage(
            "Task index entered is invalid. Please provide a valid index!",
            FeedbackType.ERROR);
    public static final FeedbackMessage ERROR_UNRECOGNIZED_COMMAND = new FeedbackMessage(
            "Command not recognized.", FeedbackType.ERROR);

    /**
     * Enumeration of the styling for different types of user feedback messages.
     * The color of font to be used for each feedback type can be retrieved via
     * {@link #getAWTColor()} or {@link #getFXColor()}
     * 
     * @author Zhu Chunqi
     *
     */
    public enum FeedbackType {
        INFO(Color.BLACK), ERROR(Color.RED);

        private Color mColor;

        private FeedbackType(Color color) {
            mColor = color;
        }

        /**
         * Retrieves the color that should be used to style this type of
         * feedback message
         * 
         * @return AWT Color object to be used for this type of feedback
         */
        public Color getAWTColor() {
            return mColor;
        }

        /**
         * Retrieves the color that should be used to style this type of
         * feedback message
         * 
         * @return JavaFX Color object to be used for this type of feedback
         */
        public javafx.scene.paint.Color getFXColor() {
            return javafx.scene.paint.Color.rgb(mColor.getRed(),
                    mColor.getGreen(), mColor.getBlue());
        }
    }

    private String mMessage;
    private FeedbackType mType;

    public FeedbackMessage(String message, FeedbackType type) {
        mMessage = message;
        mType = type;
    }

    /**
     * Retrieves the string message text
     * 
     * @return String message text
     */
    public String getMessage() {
        return mMessage;
    }

    /**
     * Retrieves the {@link FeedbackType} object containing the styling
     * information for this feedback message
     * 
     * @return {@link FeedbackType} object for this feedback message
     */
    public FeedbackType getType() {
        return mType;
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\ui\FXUI.java
``` java

/**
 * {@link UIInterface} component built using JavaFX.
 * 
 * @author Zhu Chunqi
 */
public class FXUI implements UIInterface, EventHandler<KeyEvent> {
    public static final PrettyTime PRETTY_TIME = new PrettyTime();
    public static final double ID_MIN_WIDTH = 35;
    public static final double HELP_MIN_WIDTH = 400;
    public static final double HELP_MIN_HEIGHT = 400;

    private static final Logger LOGGER = Logger.getLogger(FXUI.class.getName());

    private static FXUI sInstance;

    private final Label mFeedbackLabel;
    private final TextField mTextField;
    private final List<Task> mOrderedTasks;
    private final FilterChain mFilterChain;
    private final FXCategoryAccordion mFilteredCategory;
    private final FXCategoryAccordion mFloatingCategory;
    private final FXCategoryAccordion mUpcomingCategory;
    private final VBox mCenterVBox;
    private final BorderPane mContainer;
    private final Stage mHelpWindow;

    private LogicInterface mLogic;

    /**
     * Private constructor
     */
    private FXUI() {
        mFeedbackLabel = new Label("Welcome to FunDUE!");
        mFeedbackLabel.getStyleClass().add("smallerFont");
        mFeedbackLabel.setId("mFeedbackLabel");

        mTextField = new TextField();
        mTextField.getStyleClass().add("normalFont");
        mTextField.setOnKeyPressed(this);
        mTextField.setMaxWidth(Double.MAX_VALUE);
        mTextField.setId("mTextField");
        DropShadow borderGlow = new DropShadow(BlurType.GAUSSIAN, Color.ORANGE,
                15.0, 0.0, 0.0, 0.0);
        mTextField.focusedProperty().addListener(new ChangeListener<Boolean>() {
            @Override
            public void changed(ObservableValue<? extends Boolean> ov,
                    Boolean oldPropertyValue, Boolean newPropertyValue) {
                if (newPropertyValue) {
                    mTextField.setEffect(borderGlow);
                } else {
                    mTextField.setEffect(null);
                }
            }
        });

        mOrderedTasks = new ArrayList<Task>();

        mFilterChain = new FilterChain();
        mFilteredCategory = new FXCategoryAccordion("");
        // NOTE: Binding the managed property to the visible property to
        // properly hide the UI element when visible is set to false. Otherwise
        // the element will still take up space in layout as it is still managed
        mFilteredCategory.managedProperty()
                .bind(mFilteredCategory.visibleProperty());

        mFloatingCategory = new FXCategoryAccordion("Someday");
        mFloatingCategory.managedProperty()
                .bind(mFloatingCategory.visibleProperty());

        mUpcomingCategory = new FXCategoryAccordion("Events / Deadlines");
        mUpcomingCategory.managedProperty()
                .bind(mUpcomingCategory.visibleProperty());

        mCenterVBox = new VBox(mFilteredCategory, mFloatingCategory,
                mUpcomingCategory);
        mCenterVBox.setId("mCenterVBox");

        ScrollPane displayScrollPane = new ScrollPane(mCenterVBox) {
            // Override to prevent blue focus highlights from appearing
            @Override
            public void requestFocus() {
                // Do nothing
            }
        };
        displayScrollPane.setFitToWidth(true);
        displayScrollPane.setFitToHeight(true);
        displayScrollPane.getStyleClass().add("scrollpane");

        VBox bottomVBox = new VBox(mFeedbackLabel, mTextField);
        bottomVBox.setId("bottomVBox");

        mContainer = new BorderPane();
        mContainer.setId("container");
        mContainer.setCenter(displayScrollPane);
        mContainer.setBottom(bottomVBox);
        mContainer.getStylesheets()
                .add(getClass().getResource("styleFX.css").toExternalForm());

        mHelpWindow = new Stage();
        mHelpWindow.setTitle("FunDUE Help Page");
        mHelpWindow.setMinWidth(400);
        mHelpWindow.setMinHeight(400);
    }

    /**
     * Retrieves the singleton instance of this {@link UIInterface} component
     * 
     * @return {@link UIInterface} component singleton instance
     */
    public synchronized static FXUI getInstance() {
        if (sInstance == null) {
            sInstance = new FXUI();
        }
        return sInstance;
    }

    @Override
    public void injectDependency(LogicInterface logic) {
        mLogic = logic;
        createHelpPage(mLogic);
    }

    @Override
    public void display(ArrayList<Task> tasks) {
        // Clear the ordered task list
        mOrderedTasks.clear();

        // Sorts new task list
        Collections.sort(tasks);

        // Re-seed the filter chain
        mFilterChain.updateFilters(tasks);

        if (mFilterChain.size() > 1) {
            List<Task> filteredTasks = mFilterChain.getTasksForDisplay();
            mFilteredCategory.setName(mFilterChain.getFilterChain());
            mFilteredCategory.update(filteredTasks, mOrderedTasks.size());
            mOrderedTasks.addAll(filteredTasks);

            mFilteredCategory.setVisible(true);
            mFloatingCategory.setVisible(false);
            mUpcomingCategory.setVisible(false);
        } else {
            // Someday
            List<Task> floatingTasks = tasks.stream().sorted()
                    .filter((Task t) -> t.getEnd() == null)
                    .collect(Collectors.toList());
            mFloatingCategory.update(floatingTasks, mOrderedTasks.size());
            mOrderedTasks.addAll(floatingTasks);

            // Upcoming
            List<Task> upcomingTasks = tasks.stream().sorted()
                    .filter((Task t) -> t.getEnd() != null)
                    .collect(Collectors.toList());
            mUpcomingCategory.update(upcomingTasks, mOrderedTasks.size());
            mOrderedTasks.addAll(upcomingTasks);

            mFilteredCategory.setVisible(false);
            mFloatingCategory.setVisible(true);
            mUpcomingCategory.setVisible(true);
        }
    }

    @Override
    public Task getTask(int index) throws TaskNotFoundException {
        try {
            // NOTE: list is zero indexed whereas display is 1 indexed
            return mOrderedTasks.get(index - 1);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
    }

    @Override
    public void feedback(FeedbackMessage f) {
        mFeedbackLabel.setTextFill(f.getType().getFXColor());
        mFeedbackLabel.setText(f.getMessage());
    }

    @Override
    public String getFeedbackMessageString() {
        return mFeedbackLabel.getText();
    }

    @Override
    public void pushFilter(Filter filter) {
        mFilterChain.pushFilter(filter);
    }

    @Override
    public Filter popFilter() {
        return mFilterChain.popFilter();
    }

    @Override
    public boolean showChangeDataFilePathDialog() {
        FileChooser fc = new FileChooser();
        fc.setTitle("Select FunDUE Data File");
        fc.setInitialDirectory(mLogic.getDataFile().getParentFile());
        fc.setInitialFileName(mLogic.getDataFile().getName());
        fc.getExtensionFilters()
                .add(new ExtensionFilter("FunDUE Data Files", "*.txt"));
        File selectedFile = fc.showSaveDialog(null);
        if (selectedFile == null) {
            return false;
        } else {
            LOGGER.log(Level.INFO,
                    "Selected data file: " + selectedFile.getAbsolutePath());
            mLogic.setDataFile(selectedFile);
            return true;
        }
    }

    @Override
    public boolean showHelpPage() {
        if (mHelpWindow.isShowing()) {
            mHelpWindow.requestFocus();
            return false;
        } else {
            mHelpWindow.show();
            mHelpWindow.requestFocus();
            return true;
        }
    }

    @Override
    public void focusCommandBar() {
        mTextField.requestFocus();
    }

    @Override
    public Parent getUI() {
        return mContainer;
    }

    @Override
    public void handle(KeyEvent event) {
        switch (event.getCode()) {
          case ENTER :
            mLogic.executeCommand(mTextField.getText());
            mTextField.setText("");
            break;
          case ESCAPE :
            Platform.exit();
            break;
          default :
            // Do nothing
        }
    }

    /**
     * Creates the UI elements necessary to display the help page using
     * information provided by the loaded {@link CommandHandler} objects.
     * 
     * @param logic
     *            {@link LogicInterface} component from which to obtain the
     *            loaded {@link CommandHandler} objects.
     */
    private void createHelpPage(LogicInterface logic) {
        // Create a styled container and scroll pane
        VBox container = new VBox();
        ScrollPane scrollPane = new ScrollPane(container);
        scrollPane.setFitToWidth(true);
        Scene scene = new Scene(scrollPane, HELP_MIN_WIDTH, HELP_MIN_HEIGHT);
        scene.getStylesheets()
                .add(getClass().getResource("styleFX.css").toExternalForm());

        // Retrieve all distinct CommandHandlers and iterate
        List<CommandHandler> handlers = logic.getCommandHandlers().values()
                .stream().distinct().collect(Collectors.toList());
        for (CommandHandler handler : handlers) {
            // Create a row container for each CommandHandler
            VBox row = new VBox();
            row.getStyleClass().addAll("helpCategoryRow");

            // CommandHandler name
            Label handlerName = new Label(handler.getName());
            handlerName.getStyleClass().addAll("helpCategoryLabel");

            // CommandHandler syntax
            Label handlerUsage = new Label(
                    "Usage: " + handler.getReservedKeywords() + " "
                            + handler.getSyntax());
            handlerUsage.getStyleClass().add("wrappingText");

            // CommandHandler flags
            VBox flagsContainer = new VBox();
            for (String flag : handler.getFlags()) {
                Label flagLabel = new Label(flag);
                flagLabel.getStyleClass().addAll("wrappingText",
                        "helpTabbedLabel");
                flagsContainer.getChildren().add(flagLabel);
            }

            // CommandHandler options
            VBox optionsContainer = new VBox();
            for (String option : handler.getOptions()) {
                Label optionLabel = new Label(option);
                optionLabel.getStyleClass().addAll("wrappingText",
                        "helpTabbedLabel");
                optionsContainer.getChildren().add(optionLabel);
            }

            row.getChildren().addAll(handlerName, handlerUsage, flagsContainer,
                    optionsContainer);
            container.getChildren().add(row);
        }
        mHelpWindow.setScene(scene);
    }
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\ui\UIInterface.java
``` java

public interface UIInterface {
    /**
     * Injects the dependency on a {@link LogicInterface} component into this
     * {@link UIInterface} component.
     * 
     * @param logic
     *            A {@link LogicInterface} component. A handle to this object
     *            will be retained to access the {@link LogicInterface} methods.
     */
    public void injectDependency(LogicInterface logic);

    /**
     * Displays the provided list of {@link Task} objects.
     * 
     * @param tasks
     *            List of {@link Task} objects to be displayed.
     */
    public void display(ArrayList<Task> tasks);

    /**
     * Retrieves the Task object associated with the index provided. The general
     * contract is that the display will associate an unique integer index to
     * each Task object whenever {@link #display(ArrayList)} is called
     * 
     * @param index
     *            Integer index associated with a displayed Task object
     * @return Task object associated with the provided index
     * @throws TaskNotFoundException
     *             Thrown when the provided index is out of bounds
     */
    public Task getTask(int index) throws TaskNotFoundException;

    /**
     * Displays the provided FeedbackMessage object to the user. The
     * FeedbackMessage object encapsulates the feedback message text as well as
     * the styling with which to display the message
     * 
     * @param f
     *            FeedbackMessage object to be displayed
     * @see FeedbackMessage
     */
    public void feedback(FeedbackMessage f);

    /**
     * Retrieves the string message content of the last {@link FeedbackMessage}
     * object that was displayed.
     * 
     * @return String message content of last displayed {@link FeedbackMessage}
     *         object.
     */
    public String getFeedbackMessageString();

    /**
     * Adds the provided {@link Filter} object to the filter chain. The filtered
     * list of Task objects will then be displayed
     * 
     * @param filter
     *            Filter object to add to the filter chain
     */
    public void pushFilter(Filter filter);

    /**
     * Removes the final {@link Filter} object in the filter chain and returns
     * it. If only the root filter is remaining, this method does nothing and
     * returns {@code null}
     * 
     * @return Popped {@link Filter} object or {@code null} if only the root
     *         {@link Filter} remains
     */
    public Filter popFilter();

    /**
     * Shows a file picker dialog which prompts the user to select a FunDUE data
     * file. Returns {@code true} if a file is successfully chosen, the user's
     * preference will be updated and the selected file will used as the FunDUE
     * data file.
     * 
     * @return {@code True} if a file was selected, {@code false} otherwise.
     */
    public boolean showChangeDataFilePathDialog();

    /**
     * Shows the window containing the FunDUE Help Page. Return value indicates
     * whether the window was opened by the method.
     * 
     * @return {@code True} if the FunDUE Help Page was shown, {@code false} if
     *         the window was already showing.
     */
    public boolean showHelpPage();

    /**
     * Attempts to place focus on the command bar text field input.
     */
    public void focusCommandBar();

    /**
     * Retrieves the UI elements to be displayed in a {@link Parent} container.
     * 
     * @return {@link Parent} object to be displayed.
     */
    public Parent getUI();
}
```
###### src\sg\edu\cs2103aug2015_w13_2j\ui\UIStub.java
``` java

/**
 * {@link UIInterface} component for testing purposes. Does <b>not</b> present
 * an actual user interface. Provides methods to retrieve values passed to the
 * public {@link UIInterface} methods for assertion.
 * 
 * @author Zhu Chunqi
 */
public class UIStub implements UIInterface {
    private static final Logger LOGGER = Logger
            .getLogger(UIStub.class.getName());

    private ArrayList<Task> mOrderedTasks;
    private FeedbackMessage mFeedback;
    private FilterChain mFilterChain;

    public UIStub() {
        mFilterChain = new FilterChain();
        mOrderedTasks = new ArrayList<Task>();
    }

    @Override
    public void injectDependency(LogicInterface Logic) {
        // Do nothing
    }

    @Override
    public void display(ArrayList<Task> tasks) {
        // Re-seed the filter chain
        mFilterChain.updateFilters(tasks);

        // Clear the ordered task list
        mOrderedTasks.clear();

        if (mFilterChain.size() > 1) {
            List<Task> filteredTasks = mFilterChain.getTasksForDisplay();
            mOrderedTasks.addAll(filteredTasks);
        } else {
            // Someday
            List<Task> floatingTasks = tasks.stream().sorted()
                    .filter((Task t) -> t.getEnd() == null)
                    .collect(Collectors.toList());
            mOrderedTasks.addAll(floatingTasks);

            // Upcoming
            List<Task> upcomingTasks = tasks.stream().sorted()
                    .filter((Task t) -> t.getEnd() != null)
                    .collect(Collectors.toList());
            mOrderedTasks.addAll(upcomingTasks);
        }
    }

    @Override
    public Task getTask(int index) throws TaskNotFoundException {
        try {
            // NOTE: list is zero indexed whereas display is 1 indexed
            return mOrderedTasks.get(index - 1);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
    }

    @Override
    public void feedback(FeedbackMessage feedback) {
        mFeedback = feedback;
        LOGGER.log(Level.INFO, mFeedback.getMessage());
    }

    @Override
    public String getFeedbackMessageString() {
        return mFeedback.getMessage();
    }

```
